// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'http_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$HttpFailure {
  Object? get error => throw _privateConstructorUsedError;
  StackTrace? get stackTrace => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(DioException? error, StackTrace? stackTrace)
        connectionTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        sendTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        receiveTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        requestCancel,
    required TResult Function(SocketException? error, StackTrace? stackTrace)
        noInternetConnection,
    required TResult Function(Object? error, StackTrace? stackTrace)
        unableToProcessData,
    required TResult Function(Object? error, StackTrace? stackTrace)
        unexpectedError,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        informationalResponse,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        redirectionMessage,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        clientError,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        serverError,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        badCertificate,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        connectionError,
    required TResult Function(Object? error, StackTrace? stackTrace) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        connectionTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)? sendTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        receiveTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        requestCancel,
    TResult? Function(SocketException? error, StackTrace? stackTrace)?
        noInternetConnection,
    TResult? Function(Object? error, StackTrace? stackTrace)?
        unableToProcessData,
    TResult? Function(Object? error, StackTrace? stackTrace)? unexpectedError,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        informationalResponse,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        redirectionMessage,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        clientError,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        serverError,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        badCertificate,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        connectionError,
    TResult? Function(Object? error, StackTrace? stackTrace)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DioException? error, StackTrace? stackTrace)?
        connectionTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)? sendTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        receiveTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        requestCancel,
    TResult Function(SocketException? error, StackTrace? stackTrace)?
        noInternetConnection,
    TResult Function(Object? error, StackTrace? stackTrace)?
        unableToProcessData,
    TResult Function(Object? error, StackTrace? stackTrace)? unexpectedError,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        informationalResponse,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        redirectionMessage,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        clientError,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        serverError,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        badCertificate,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        connectionError,
    TResult Function(Object? error, StackTrace? stackTrace)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConnectionTimeout value) connectionTimeout,
    required TResult Function(SendTimeout value) sendTimeout,
    required TResult Function(ReceiveTimeout value) receiveTimeout,
    required TResult Function(RequestCancelled value) requestCancel,
    required TResult Function(NoInternetConnection value) noInternetConnection,
    required TResult Function(UnableToProcessData value) unableToProcessData,
    required TResult Function(UnexpectedError value) unexpectedError,
    required TResult Function(InformationalResponse value)
        informationalResponse,
    required TResult Function(RedirectionMessage value) redirectionMessage,
    required TResult Function(ClientError value) clientError,
    required TResult Function(ServerError value) serverError,
    required TResult Function(BadCertificate value) badCertificate,
    required TResult Function(ConnectionError value) connectionError,
    required TResult Function(UnknownException value) unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConnectionTimeout value)? connectionTimeout,
    TResult? Function(SendTimeout value)? sendTimeout,
    TResult? Function(ReceiveTimeout value)? receiveTimeout,
    TResult? Function(RequestCancelled value)? requestCancel,
    TResult? Function(NoInternetConnection value)? noInternetConnection,
    TResult? Function(UnableToProcessData value)? unableToProcessData,
    TResult? Function(UnexpectedError value)? unexpectedError,
    TResult? Function(InformationalResponse value)? informationalResponse,
    TResult? Function(RedirectionMessage value)? redirectionMessage,
    TResult? Function(ClientError value)? clientError,
    TResult? Function(ServerError value)? serverError,
    TResult? Function(BadCertificate value)? badCertificate,
    TResult? Function(ConnectionError value)? connectionError,
    TResult? Function(UnknownException value)? unknown,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConnectionTimeout value)? connectionTimeout,
    TResult Function(SendTimeout value)? sendTimeout,
    TResult Function(ReceiveTimeout value)? receiveTimeout,
    TResult Function(RequestCancelled value)? requestCancel,
    TResult Function(NoInternetConnection value)? noInternetConnection,
    TResult Function(UnableToProcessData value)? unableToProcessData,
    TResult Function(UnexpectedError value)? unexpectedError,
    TResult Function(InformationalResponse value)? informationalResponse,
    TResult Function(RedirectionMessage value)? redirectionMessage,
    TResult Function(ClientError value)? clientError,
    TResult Function(ServerError value)? serverError,
    TResult Function(BadCertificate value)? badCertificate,
    TResult Function(ConnectionError value)? connectionError,
    TResult Function(UnknownException value)? unknown,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $HttpFailureCopyWith<HttpFailure> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HttpFailureCopyWith<$Res> {
  factory $HttpFailureCopyWith(
          HttpFailure value, $Res Function(HttpFailure) then) =
      _$HttpFailureCopyWithImpl<$Res, HttpFailure>;
  @useResult
  $Res call({StackTrace? stackTrace});
}

/// @nodoc
class _$HttpFailureCopyWithImpl<$Res, $Val extends HttpFailure>
    implements $HttpFailureCopyWith<$Res> {
  _$HttpFailureCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? stackTrace = freezed,
  }) {
    return _then(_value.copyWith(
      stackTrace: freezed == stackTrace
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ConnectionTimeoutImplCopyWith<$Res>
    implements $HttpFailureCopyWith<$Res> {
  factory _$$ConnectionTimeoutImplCopyWith(_$ConnectionTimeoutImpl value,
          $Res Function(_$ConnectionTimeoutImpl) then) =
      __$$ConnectionTimeoutImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({DioException? error, StackTrace? stackTrace});
}

/// @nodoc
class __$$ConnectionTimeoutImplCopyWithImpl<$Res>
    extends _$HttpFailureCopyWithImpl<$Res, _$ConnectionTimeoutImpl>
    implements _$$ConnectionTimeoutImplCopyWith<$Res> {
  __$$ConnectionTimeoutImplCopyWithImpl(_$ConnectionTimeoutImpl _value,
      $Res Function(_$ConnectionTimeoutImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = freezed,
    Object? stackTrace = freezed,
  }) {
    return _then(_$ConnectionTimeoutImpl(
      freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as DioException?,
      freezed == stackTrace
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace?,
    ));
  }
}

/// @nodoc

class _$ConnectionTimeoutImpl extends ConnectionTimeout {
  const _$ConnectionTimeoutImpl([this.error, this.stackTrace]) : super._();

  @override
  final DioException? error;
  @override
  final StackTrace? stackTrace;

  @override
  String toString() {
    return 'HttpFailure.connectionTimeout(error: $error, stackTrace: $stackTrace)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConnectionTimeoutImpl &&
            (identical(other.error, error) || other.error == error) &&
            (identical(other.stackTrace, stackTrace) ||
                other.stackTrace == stackTrace));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error, stackTrace);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ConnectionTimeoutImplCopyWith<_$ConnectionTimeoutImpl> get copyWith =>
      __$$ConnectionTimeoutImplCopyWithImpl<_$ConnectionTimeoutImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(DioException? error, StackTrace? stackTrace)
        connectionTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        sendTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        receiveTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        requestCancel,
    required TResult Function(SocketException? error, StackTrace? stackTrace)
        noInternetConnection,
    required TResult Function(Object? error, StackTrace? stackTrace)
        unableToProcessData,
    required TResult Function(Object? error, StackTrace? stackTrace)
        unexpectedError,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        informationalResponse,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        redirectionMessage,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        clientError,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        serverError,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        badCertificate,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        connectionError,
    required TResult Function(Object? error, StackTrace? stackTrace) unknown,
  }) {
    return connectionTimeout(error, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        connectionTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)? sendTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        receiveTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        requestCancel,
    TResult? Function(SocketException? error, StackTrace? stackTrace)?
        noInternetConnection,
    TResult? Function(Object? error, StackTrace? stackTrace)?
        unableToProcessData,
    TResult? Function(Object? error, StackTrace? stackTrace)? unexpectedError,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        informationalResponse,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        redirectionMessage,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        clientError,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        serverError,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        badCertificate,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        connectionError,
    TResult? Function(Object? error, StackTrace? stackTrace)? unknown,
  }) {
    return connectionTimeout?.call(error, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DioException? error, StackTrace? stackTrace)?
        connectionTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)? sendTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        receiveTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        requestCancel,
    TResult Function(SocketException? error, StackTrace? stackTrace)?
        noInternetConnection,
    TResult Function(Object? error, StackTrace? stackTrace)?
        unableToProcessData,
    TResult Function(Object? error, StackTrace? stackTrace)? unexpectedError,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        informationalResponse,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        redirectionMessage,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        clientError,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        serverError,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        badCertificate,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        connectionError,
    TResult Function(Object? error, StackTrace? stackTrace)? unknown,
    required TResult orElse(),
  }) {
    if (connectionTimeout != null) {
      return connectionTimeout(error, stackTrace);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConnectionTimeout value) connectionTimeout,
    required TResult Function(SendTimeout value) sendTimeout,
    required TResult Function(ReceiveTimeout value) receiveTimeout,
    required TResult Function(RequestCancelled value) requestCancel,
    required TResult Function(NoInternetConnection value) noInternetConnection,
    required TResult Function(UnableToProcessData value) unableToProcessData,
    required TResult Function(UnexpectedError value) unexpectedError,
    required TResult Function(InformationalResponse value)
        informationalResponse,
    required TResult Function(RedirectionMessage value) redirectionMessage,
    required TResult Function(ClientError value) clientError,
    required TResult Function(ServerError value) serverError,
    required TResult Function(BadCertificate value) badCertificate,
    required TResult Function(ConnectionError value) connectionError,
    required TResult Function(UnknownException value) unknown,
  }) {
    return connectionTimeout(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConnectionTimeout value)? connectionTimeout,
    TResult? Function(SendTimeout value)? sendTimeout,
    TResult? Function(ReceiveTimeout value)? receiveTimeout,
    TResult? Function(RequestCancelled value)? requestCancel,
    TResult? Function(NoInternetConnection value)? noInternetConnection,
    TResult? Function(UnableToProcessData value)? unableToProcessData,
    TResult? Function(UnexpectedError value)? unexpectedError,
    TResult? Function(InformationalResponse value)? informationalResponse,
    TResult? Function(RedirectionMessage value)? redirectionMessage,
    TResult? Function(ClientError value)? clientError,
    TResult? Function(ServerError value)? serverError,
    TResult? Function(BadCertificate value)? badCertificate,
    TResult? Function(ConnectionError value)? connectionError,
    TResult? Function(UnknownException value)? unknown,
  }) {
    return connectionTimeout?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConnectionTimeout value)? connectionTimeout,
    TResult Function(SendTimeout value)? sendTimeout,
    TResult Function(ReceiveTimeout value)? receiveTimeout,
    TResult Function(RequestCancelled value)? requestCancel,
    TResult Function(NoInternetConnection value)? noInternetConnection,
    TResult Function(UnableToProcessData value)? unableToProcessData,
    TResult Function(UnexpectedError value)? unexpectedError,
    TResult Function(InformationalResponse value)? informationalResponse,
    TResult Function(RedirectionMessage value)? redirectionMessage,
    TResult Function(ClientError value)? clientError,
    TResult Function(ServerError value)? serverError,
    TResult Function(BadCertificate value)? badCertificate,
    TResult Function(ConnectionError value)? connectionError,
    TResult Function(UnknownException value)? unknown,
    required TResult orElse(),
  }) {
    if (connectionTimeout != null) {
      return connectionTimeout(this);
    }
    return orElse();
  }
}

abstract class ConnectionTimeout extends HttpFailure {
  const factory ConnectionTimeout(
      [final DioException? error,
      final StackTrace? stackTrace]) = _$ConnectionTimeoutImpl;
  const ConnectionTimeout._() : super._();

  @override
  DioException? get error;
  @override
  StackTrace? get stackTrace;
  @override
  @JsonKey(ignore: true)
  _$$ConnectionTimeoutImplCopyWith<_$ConnectionTimeoutImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SendTimeoutImplCopyWith<$Res>
    implements $HttpFailureCopyWith<$Res> {
  factory _$$SendTimeoutImplCopyWith(
          _$SendTimeoutImpl value, $Res Function(_$SendTimeoutImpl) then) =
      __$$SendTimeoutImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({DioException? error, StackTrace? stackTrace});
}

/// @nodoc
class __$$SendTimeoutImplCopyWithImpl<$Res>
    extends _$HttpFailureCopyWithImpl<$Res, _$SendTimeoutImpl>
    implements _$$SendTimeoutImplCopyWith<$Res> {
  __$$SendTimeoutImplCopyWithImpl(
      _$SendTimeoutImpl _value, $Res Function(_$SendTimeoutImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = freezed,
    Object? stackTrace = freezed,
  }) {
    return _then(_$SendTimeoutImpl(
      freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as DioException?,
      freezed == stackTrace
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace?,
    ));
  }
}

/// @nodoc

class _$SendTimeoutImpl extends SendTimeout {
  const _$SendTimeoutImpl([this.error, this.stackTrace]) : super._();

  @override
  final DioException? error;
  @override
  final StackTrace? stackTrace;

  @override
  String toString() {
    return 'HttpFailure.sendTimeout(error: $error, stackTrace: $stackTrace)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SendTimeoutImpl &&
            (identical(other.error, error) || other.error == error) &&
            (identical(other.stackTrace, stackTrace) ||
                other.stackTrace == stackTrace));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error, stackTrace);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SendTimeoutImplCopyWith<_$SendTimeoutImpl> get copyWith =>
      __$$SendTimeoutImplCopyWithImpl<_$SendTimeoutImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(DioException? error, StackTrace? stackTrace)
        connectionTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        sendTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        receiveTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        requestCancel,
    required TResult Function(SocketException? error, StackTrace? stackTrace)
        noInternetConnection,
    required TResult Function(Object? error, StackTrace? stackTrace)
        unableToProcessData,
    required TResult Function(Object? error, StackTrace? stackTrace)
        unexpectedError,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        informationalResponse,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        redirectionMessage,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        clientError,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        serverError,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        badCertificate,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        connectionError,
    required TResult Function(Object? error, StackTrace? stackTrace) unknown,
  }) {
    return sendTimeout(error, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        connectionTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)? sendTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        receiveTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        requestCancel,
    TResult? Function(SocketException? error, StackTrace? stackTrace)?
        noInternetConnection,
    TResult? Function(Object? error, StackTrace? stackTrace)?
        unableToProcessData,
    TResult? Function(Object? error, StackTrace? stackTrace)? unexpectedError,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        informationalResponse,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        redirectionMessage,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        clientError,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        serverError,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        badCertificate,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        connectionError,
    TResult? Function(Object? error, StackTrace? stackTrace)? unknown,
  }) {
    return sendTimeout?.call(error, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DioException? error, StackTrace? stackTrace)?
        connectionTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)? sendTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        receiveTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        requestCancel,
    TResult Function(SocketException? error, StackTrace? stackTrace)?
        noInternetConnection,
    TResult Function(Object? error, StackTrace? stackTrace)?
        unableToProcessData,
    TResult Function(Object? error, StackTrace? stackTrace)? unexpectedError,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        informationalResponse,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        redirectionMessage,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        clientError,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        serverError,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        badCertificate,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        connectionError,
    TResult Function(Object? error, StackTrace? stackTrace)? unknown,
    required TResult orElse(),
  }) {
    if (sendTimeout != null) {
      return sendTimeout(error, stackTrace);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConnectionTimeout value) connectionTimeout,
    required TResult Function(SendTimeout value) sendTimeout,
    required TResult Function(ReceiveTimeout value) receiveTimeout,
    required TResult Function(RequestCancelled value) requestCancel,
    required TResult Function(NoInternetConnection value) noInternetConnection,
    required TResult Function(UnableToProcessData value) unableToProcessData,
    required TResult Function(UnexpectedError value) unexpectedError,
    required TResult Function(InformationalResponse value)
        informationalResponse,
    required TResult Function(RedirectionMessage value) redirectionMessage,
    required TResult Function(ClientError value) clientError,
    required TResult Function(ServerError value) serverError,
    required TResult Function(BadCertificate value) badCertificate,
    required TResult Function(ConnectionError value) connectionError,
    required TResult Function(UnknownException value) unknown,
  }) {
    return sendTimeout(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConnectionTimeout value)? connectionTimeout,
    TResult? Function(SendTimeout value)? sendTimeout,
    TResult? Function(ReceiveTimeout value)? receiveTimeout,
    TResult? Function(RequestCancelled value)? requestCancel,
    TResult? Function(NoInternetConnection value)? noInternetConnection,
    TResult? Function(UnableToProcessData value)? unableToProcessData,
    TResult? Function(UnexpectedError value)? unexpectedError,
    TResult? Function(InformationalResponse value)? informationalResponse,
    TResult? Function(RedirectionMessage value)? redirectionMessage,
    TResult? Function(ClientError value)? clientError,
    TResult? Function(ServerError value)? serverError,
    TResult? Function(BadCertificate value)? badCertificate,
    TResult? Function(ConnectionError value)? connectionError,
    TResult? Function(UnknownException value)? unknown,
  }) {
    return sendTimeout?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConnectionTimeout value)? connectionTimeout,
    TResult Function(SendTimeout value)? sendTimeout,
    TResult Function(ReceiveTimeout value)? receiveTimeout,
    TResult Function(RequestCancelled value)? requestCancel,
    TResult Function(NoInternetConnection value)? noInternetConnection,
    TResult Function(UnableToProcessData value)? unableToProcessData,
    TResult Function(UnexpectedError value)? unexpectedError,
    TResult Function(InformationalResponse value)? informationalResponse,
    TResult Function(RedirectionMessage value)? redirectionMessage,
    TResult Function(ClientError value)? clientError,
    TResult Function(ServerError value)? serverError,
    TResult Function(BadCertificate value)? badCertificate,
    TResult Function(ConnectionError value)? connectionError,
    TResult Function(UnknownException value)? unknown,
    required TResult orElse(),
  }) {
    if (sendTimeout != null) {
      return sendTimeout(this);
    }
    return orElse();
  }
}

abstract class SendTimeout extends HttpFailure {
  const factory SendTimeout(
      [final DioException? error,
      final StackTrace? stackTrace]) = _$SendTimeoutImpl;
  const SendTimeout._() : super._();

  @override
  DioException? get error;
  @override
  StackTrace? get stackTrace;
  @override
  @JsonKey(ignore: true)
  _$$SendTimeoutImplCopyWith<_$SendTimeoutImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ReceiveTimeoutImplCopyWith<$Res>
    implements $HttpFailureCopyWith<$Res> {
  factory _$$ReceiveTimeoutImplCopyWith(_$ReceiveTimeoutImpl value,
          $Res Function(_$ReceiveTimeoutImpl) then) =
      __$$ReceiveTimeoutImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({DioException? error, StackTrace? stackTrace});
}

/// @nodoc
class __$$ReceiveTimeoutImplCopyWithImpl<$Res>
    extends _$HttpFailureCopyWithImpl<$Res, _$ReceiveTimeoutImpl>
    implements _$$ReceiveTimeoutImplCopyWith<$Res> {
  __$$ReceiveTimeoutImplCopyWithImpl(
      _$ReceiveTimeoutImpl _value, $Res Function(_$ReceiveTimeoutImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = freezed,
    Object? stackTrace = freezed,
  }) {
    return _then(_$ReceiveTimeoutImpl(
      freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as DioException?,
      freezed == stackTrace
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace?,
    ));
  }
}

/// @nodoc

class _$ReceiveTimeoutImpl extends ReceiveTimeout {
  const _$ReceiveTimeoutImpl([this.error, this.stackTrace]) : super._();

  @override
  final DioException? error;
  @override
  final StackTrace? stackTrace;

  @override
  String toString() {
    return 'HttpFailure.receiveTimeout(error: $error, stackTrace: $stackTrace)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ReceiveTimeoutImpl &&
            (identical(other.error, error) || other.error == error) &&
            (identical(other.stackTrace, stackTrace) ||
                other.stackTrace == stackTrace));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error, stackTrace);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ReceiveTimeoutImplCopyWith<_$ReceiveTimeoutImpl> get copyWith =>
      __$$ReceiveTimeoutImplCopyWithImpl<_$ReceiveTimeoutImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(DioException? error, StackTrace? stackTrace)
        connectionTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        sendTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        receiveTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        requestCancel,
    required TResult Function(SocketException? error, StackTrace? stackTrace)
        noInternetConnection,
    required TResult Function(Object? error, StackTrace? stackTrace)
        unableToProcessData,
    required TResult Function(Object? error, StackTrace? stackTrace)
        unexpectedError,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        informationalResponse,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        redirectionMessage,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        clientError,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        serverError,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        badCertificate,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        connectionError,
    required TResult Function(Object? error, StackTrace? stackTrace) unknown,
  }) {
    return receiveTimeout(error, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        connectionTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)? sendTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        receiveTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        requestCancel,
    TResult? Function(SocketException? error, StackTrace? stackTrace)?
        noInternetConnection,
    TResult? Function(Object? error, StackTrace? stackTrace)?
        unableToProcessData,
    TResult? Function(Object? error, StackTrace? stackTrace)? unexpectedError,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        informationalResponse,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        redirectionMessage,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        clientError,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        serverError,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        badCertificate,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        connectionError,
    TResult? Function(Object? error, StackTrace? stackTrace)? unknown,
  }) {
    return receiveTimeout?.call(error, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DioException? error, StackTrace? stackTrace)?
        connectionTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)? sendTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        receiveTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        requestCancel,
    TResult Function(SocketException? error, StackTrace? stackTrace)?
        noInternetConnection,
    TResult Function(Object? error, StackTrace? stackTrace)?
        unableToProcessData,
    TResult Function(Object? error, StackTrace? stackTrace)? unexpectedError,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        informationalResponse,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        redirectionMessage,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        clientError,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        serverError,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        badCertificate,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        connectionError,
    TResult Function(Object? error, StackTrace? stackTrace)? unknown,
    required TResult orElse(),
  }) {
    if (receiveTimeout != null) {
      return receiveTimeout(error, stackTrace);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConnectionTimeout value) connectionTimeout,
    required TResult Function(SendTimeout value) sendTimeout,
    required TResult Function(ReceiveTimeout value) receiveTimeout,
    required TResult Function(RequestCancelled value) requestCancel,
    required TResult Function(NoInternetConnection value) noInternetConnection,
    required TResult Function(UnableToProcessData value) unableToProcessData,
    required TResult Function(UnexpectedError value) unexpectedError,
    required TResult Function(InformationalResponse value)
        informationalResponse,
    required TResult Function(RedirectionMessage value) redirectionMessage,
    required TResult Function(ClientError value) clientError,
    required TResult Function(ServerError value) serverError,
    required TResult Function(BadCertificate value) badCertificate,
    required TResult Function(ConnectionError value) connectionError,
    required TResult Function(UnknownException value) unknown,
  }) {
    return receiveTimeout(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConnectionTimeout value)? connectionTimeout,
    TResult? Function(SendTimeout value)? sendTimeout,
    TResult? Function(ReceiveTimeout value)? receiveTimeout,
    TResult? Function(RequestCancelled value)? requestCancel,
    TResult? Function(NoInternetConnection value)? noInternetConnection,
    TResult? Function(UnableToProcessData value)? unableToProcessData,
    TResult? Function(UnexpectedError value)? unexpectedError,
    TResult? Function(InformationalResponse value)? informationalResponse,
    TResult? Function(RedirectionMessage value)? redirectionMessage,
    TResult? Function(ClientError value)? clientError,
    TResult? Function(ServerError value)? serverError,
    TResult? Function(BadCertificate value)? badCertificate,
    TResult? Function(ConnectionError value)? connectionError,
    TResult? Function(UnknownException value)? unknown,
  }) {
    return receiveTimeout?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConnectionTimeout value)? connectionTimeout,
    TResult Function(SendTimeout value)? sendTimeout,
    TResult Function(ReceiveTimeout value)? receiveTimeout,
    TResult Function(RequestCancelled value)? requestCancel,
    TResult Function(NoInternetConnection value)? noInternetConnection,
    TResult Function(UnableToProcessData value)? unableToProcessData,
    TResult Function(UnexpectedError value)? unexpectedError,
    TResult Function(InformationalResponse value)? informationalResponse,
    TResult Function(RedirectionMessage value)? redirectionMessage,
    TResult Function(ClientError value)? clientError,
    TResult Function(ServerError value)? serverError,
    TResult Function(BadCertificate value)? badCertificate,
    TResult Function(ConnectionError value)? connectionError,
    TResult Function(UnknownException value)? unknown,
    required TResult orElse(),
  }) {
    if (receiveTimeout != null) {
      return receiveTimeout(this);
    }
    return orElse();
  }
}

abstract class ReceiveTimeout extends HttpFailure {
  const factory ReceiveTimeout(
      [final DioException? error,
      final StackTrace? stackTrace]) = _$ReceiveTimeoutImpl;
  const ReceiveTimeout._() : super._();

  @override
  DioException? get error;
  @override
  StackTrace? get stackTrace;
  @override
  @JsonKey(ignore: true)
  _$$ReceiveTimeoutImplCopyWith<_$ReceiveTimeoutImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RequestCancelledImplCopyWith<$Res>
    implements $HttpFailureCopyWith<$Res> {
  factory _$$RequestCancelledImplCopyWith(_$RequestCancelledImpl value,
          $Res Function(_$RequestCancelledImpl) then) =
      __$$RequestCancelledImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({DioException? error, StackTrace? stackTrace});
}

/// @nodoc
class __$$RequestCancelledImplCopyWithImpl<$Res>
    extends _$HttpFailureCopyWithImpl<$Res, _$RequestCancelledImpl>
    implements _$$RequestCancelledImplCopyWith<$Res> {
  __$$RequestCancelledImplCopyWithImpl(_$RequestCancelledImpl _value,
      $Res Function(_$RequestCancelledImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = freezed,
    Object? stackTrace = freezed,
  }) {
    return _then(_$RequestCancelledImpl(
      freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as DioException?,
      freezed == stackTrace
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace?,
    ));
  }
}

/// @nodoc

class _$RequestCancelledImpl extends RequestCancelled {
  const _$RequestCancelledImpl([this.error, this.stackTrace]) : super._();

  @override
  final DioException? error;
  @override
  final StackTrace? stackTrace;

  @override
  String toString() {
    return 'HttpFailure.requestCancel(error: $error, stackTrace: $stackTrace)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RequestCancelledImpl &&
            (identical(other.error, error) || other.error == error) &&
            (identical(other.stackTrace, stackTrace) ||
                other.stackTrace == stackTrace));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error, stackTrace);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RequestCancelledImplCopyWith<_$RequestCancelledImpl> get copyWith =>
      __$$RequestCancelledImplCopyWithImpl<_$RequestCancelledImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(DioException? error, StackTrace? stackTrace)
        connectionTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        sendTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        receiveTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        requestCancel,
    required TResult Function(SocketException? error, StackTrace? stackTrace)
        noInternetConnection,
    required TResult Function(Object? error, StackTrace? stackTrace)
        unableToProcessData,
    required TResult Function(Object? error, StackTrace? stackTrace)
        unexpectedError,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        informationalResponse,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        redirectionMessage,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        clientError,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        serverError,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        badCertificate,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        connectionError,
    required TResult Function(Object? error, StackTrace? stackTrace) unknown,
  }) {
    return requestCancel(error, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        connectionTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)? sendTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        receiveTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        requestCancel,
    TResult? Function(SocketException? error, StackTrace? stackTrace)?
        noInternetConnection,
    TResult? Function(Object? error, StackTrace? stackTrace)?
        unableToProcessData,
    TResult? Function(Object? error, StackTrace? stackTrace)? unexpectedError,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        informationalResponse,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        redirectionMessage,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        clientError,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        serverError,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        badCertificate,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        connectionError,
    TResult? Function(Object? error, StackTrace? stackTrace)? unknown,
  }) {
    return requestCancel?.call(error, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DioException? error, StackTrace? stackTrace)?
        connectionTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)? sendTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        receiveTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        requestCancel,
    TResult Function(SocketException? error, StackTrace? stackTrace)?
        noInternetConnection,
    TResult Function(Object? error, StackTrace? stackTrace)?
        unableToProcessData,
    TResult Function(Object? error, StackTrace? stackTrace)? unexpectedError,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        informationalResponse,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        redirectionMessage,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        clientError,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        serverError,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        badCertificate,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        connectionError,
    TResult Function(Object? error, StackTrace? stackTrace)? unknown,
    required TResult orElse(),
  }) {
    if (requestCancel != null) {
      return requestCancel(error, stackTrace);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConnectionTimeout value) connectionTimeout,
    required TResult Function(SendTimeout value) sendTimeout,
    required TResult Function(ReceiveTimeout value) receiveTimeout,
    required TResult Function(RequestCancelled value) requestCancel,
    required TResult Function(NoInternetConnection value) noInternetConnection,
    required TResult Function(UnableToProcessData value) unableToProcessData,
    required TResult Function(UnexpectedError value) unexpectedError,
    required TResult Function(InformationalResponse value)
        informationalResponse,
    required TResult Function(RedirectionMessage value) redirectionMessage,
    required TResult Function(ClientError value) clientError,
    required TResult Function(ServerError value) serverError,
    required TResult Function(BadCertificate value) badCertificate,
    required TResult Function(ConnectionError value) connectionError,
    required TResult Function(UnknownException value) unknown,
  }) {
    return requestCancel(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConnectionTimeout value)? connectionTimeout,
    TResult? Function(SendTimeout value)? sendTimeout,
    TResult? Function(ReceiveTimeout value)? receiveTimeout,
    TResult? Function(RequestCancelled value)? requestCancel,
    TResult? Function(NoInternetConnection value)? noInternetConnection,
    TResult? Function(UnableToProcessData value)? unableToProcessData,
    TResult? Function(UnexpectedError value)? unexpectedError,
    TResult? Function(InformationalResponse value)? informationalResponse,
    TResult? Function(RedirectionMessage value)? redirectionMessage,
    TResult? Function(ClientError value)? clientError,
    TResult? Function(ServerError value)? serverError,
    TResult? Function(BadCertificate value)? badCertificate,
    TResult? Function(ConnectionError value)? connectionError,
    TResult? Function(UnknownException value)? unknown,
  }) {
    return requestCancel?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConnectionTimeout value)? connectionTimeout,
    TResult Function(SendTimeout value)? sendTimeout,
    TResult Function(ReceiveTimeout value)? receiveTimeout,
    TResult Function(RequestCancelled value)? requestCancel,
    TResult Function(NoInternetConnection value)? noInternetConnection,
    TResult Function(UnableToProcessData value)? unableToProcessData,
    TResult Function(UnexpectedError value)? unexpectedError,
    TResult Function(InformationalResponse value)? informationalResponse,
    TResult Function(RedirectionMessage value)? redirectionMessage,
    TResult Function(ClientError value)? clientError,
    TResult Function(ServerError value)? serverError,
    TResult Function(BadCertificate value)? badCertificate,
    TResult Function(ConnectionError value)? connectionError,
    TResult Function(UnknownException value)? unknown,
    required TResult orElse(),
  }) {
    if (requestCancel != null) {
      return requestCancel(this);
    }
    return orElse();
  }
}

abstract class RequestCancelled extends HttpFailure {
  const factory RequestCancelled(
      [final DioException? error,
      final StackTrace? stackTrace]) = _$RequestCancelledImpl;
  const RequestCancelled._() : super._();

  @override
  DioException? get error;
  @override
  StackTrace? get stackTrace;
  @override
  @JsonKey(ignore: true)
  _$$RequestCancelledImplCopyWith<_$RequestCancelledImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$NoInternetConnectionImplCopyWith<$Res>
    implements $HttpFailureCopyWith<$Res> {
  factory _$$NoInternetConnectionImplCopyWith(_$NoInternetConnectionImpl value,
          $Res Function(_$NoInternetConnectionImpl) then) =
      __$$NoInternetConnectionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({SocketException? error, StackTrace? stackTrace});
}

/// @nodoc
class __$$NoInternetConnectionImplCopyWithImpl<$Res>
    extends _$HttpFailureCopyWithImpl<$Res, _$NoInternetConnectionImpl>
    implements _$$NoInternetConnectionImplCopyWith<$Res> {
  __$$NoInternetConnectionImplCopyWithImpl(_$NoInternetConnectionImpl _value,
      $Res Function(_$NoInternetConnectionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = freezed,
    Object? stackTrace = freezed,
  }) {
    return _then(_$NoInternetConnectionImpl(
      freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as SocketException?,
      freezed == stackTrace
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace?,
    ));
  }
}

/// @nodoc

class _$NoInternetConnectionImpl extends NoInternetConnection {
  const _$NoInternetConnectionImpl([this.error, this.stackTrace]) : super._();

  @override
  final SocketException? error;
  @override
  final StackTrace? stackTrace;

  @override
  String toString() {
    return 'HttpFailure.noInternetConnection(error: $error, stackTrace: $stackTrace)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NoInternetConnectionImpl &&
            (identical(other.error, error) || other.error == error) &&
            (identical(other.stackTrace, stackTrace) ||
                other.stackTrace == stackTrace));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error, stackTrace);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NoInternetConnectionImplCopyWith<_$NoInternetConnectionImpl>
      get copyWith =>
          __$$NoInternetConnectionImplCopyWithImpl<_$NoInternetConnectionImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(DioException? error, StackTrace? stackTrace)
        connectionTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        sendTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        receiveTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        requestCancel,
    required TResult Function(SocketException? error, StackTrace? stackTrace)
        noInternetConnection,
    required TResult Function(Object? error, StackTrace? stackTrace)
        unableToProcessData,
    required TResult Function(Object? error, StackTrace? stackTrace)
        unexpectedError,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        informationalResponse,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        redirectionMessage,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        clientError,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        serverError,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        badCertificate,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        connectionError,
    required TResult Function(Object? error, StackTrace? stackTrace) unknown,
  }) {
    return noInternetConnection(error, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        connectionTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)? sendTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        receiveTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        requestCancel,
    TResult? Function(SocketException? error, StackTrace? stackTrace)?
        noInternetConnection,
    TResult? Function(Object? error, StackTrace? stackTrace)?
        unableToProcessData,
    TResult? Function(Object? error, StackTrace? stackTrace)? unexpectedError,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        informationalResponse,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        redirectionMessage,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        clientError,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        serverError,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        badCertificate,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        connectionError,
    TResult? Function(Object? error, StackTrace? stackTrace)? unknown,
  }) {
    return noInternetConnection?.call(error, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DioException? error, StackTrace? stackTrace)?
        connectionTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)? sendTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        receiveTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        requestCancel,
    TResult Function(SocketException? error, StackTrace? stackTrace)?
        noInternetConnection,
    TResult Function(Object? error, StackTrace? stackTrace)?
        unableToProcessData,
    TResult Function(Object? error, StackTrace? stackTrace)? unexpectedError,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        informationalResponse,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        redirectionMessage,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        clientError,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        serverError,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        badCertificate,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        connectionError,
    TResult Function(Object? error, StackTrace? stackTrace)? unknown,
    required TResult orElse(),
  }) {
    if (noInternetConnection != null) {
      return noInternetConnection(error, stackTrace);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConnectionTimeout value) connectionTimeout,
    required TResult Function(SendTimeout value) sendTimeout,
    required TResult Function(ReceiveTimeout value) receiveTimeout,
    required TResult Function(RequestCancelled value) requestCancel,
    required TResult Function(NoInternetConnection value) noInternetConnection,
    required TResult Function(UnableToProcessData value) unableToProcessData,
    required TResult Function(UnexpectedError value) unexpectedError,
    required TResult Function(InformationalResponse value)
        informationalResponse,
    required TResult Function(RedirectionMessage value) redirectionMessage,
    required TResult Function(ClientError value) clientError,
    required TResult Function(ServerError value) serverError,
    required TResult Function(BadCertificate value) badCertificate,
    required TResult Function(ConnectionError value) connectionError,
    required TResult Function(UnknownException value) unknown,
  }) {
    return noInternetConnection(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConnectionTimeout value)? connectionTimeout,
    TResult? Function(SendTimeout value)? sendTimeout,
    TResult? Function(ReceiveTimeout value)? receiveTimeout,
    TResult? Function(RequestCancelled value)? requestCancel,
    TResult? Function(NoInternetConnection value)? noInternetConnection,
    TResult? Function(UnableToProcessData value)? unableToProcessData,
    TResult? Function(UnexpectedError value)? unexpectedError,
    TResult? Function(InformationalResponse value)? informationalResponse,
    TResult? Function(RedirectionMessage value)? redirectionMessage,
    TResult? Function(ClientError value)? clientError,
    TResult? Function(ServerError value)? serverError,
    TResult? Function(BadCertificate value)? badCertificate,
    TResult? Function(ConnectionError value)? connectionError,
    TResult? Function(UnknownException value)? unknown,
  }) {
    return noInternetConnection?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConnectionTimeout value)? connectionTimeout,
    TResult Function(SendTimeout value)? sendTimeout,
    TResult Function(ReceiveTimeout value)? receiveTimeout,
    TResult Function(RequestCancelled value)? requestCancel,
    TResult Function(NoInternetConnection value)? noInternetConnection,
    TResult Function(UnableToProcessData value)? unableToProcessData,
    TResult Function(UnexpectedError value)? unexpectedError,
    TResult Function(InformationalResponse value)? informationalResponse,
    TResult Function(RedirectionMessage value)? redirectionMessage,
    TResult Function(ClientError value)? clientError,
    TResult Function(ServerError value)? serverError,
    TResult Function(BadCertificate value)? badCertificate,
    TResult Function(ConnectionError value)? connectionError,
    TResult Function(UnknownException value)? unknown,
    required TResult orElse(),
  }) {
    if (noInternetConnection != null) {
      return noInternetConnection(this);
    }
    return orElse();
  }
}

abstract class NoInternetConnection extends HttpFailure {
  const factory NoInternetConnection(
      [final SocketException? error,
      final StackTrace? stackTrace]) = _$NoInternetConnectionImpl;
  const NoInternetConnection._() : super._();

  @override
  SocketException? get error;
  @override
  StackTrace? get stackTrace;
  @override
  @JsonKey(ignore: true)
  _$$NoInternetConnectionImplCopyWith<_$NoInternetConnectionImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UnableToProcessDataImplCopyWith<$Res>
    implements $HttpFailureCopyWith<$Res> {
  factory _$$UnableToProcessDataImplCopyWith(_$UnableToProcessDataImpl value,
          $Res Function(_$UnableToProcessDataImpl) then) =
      __$$UnableToProcessDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Object? error, StackTrace? stackTrace});
}

/// @nodoc
class __$$UnableToProcessDataImplCopyWithImpl<$Res>
    extends _$HttpFailureCopyWithImpl<$Res, _$UnableToProcessDataImpl>
    implements _$$UnableToProcessDataImplCopyWith<$Res> {
  __$$UnableToProcessDataImplCopyWithImpl(_$UnableToProcessDataImpl _value,
      $Res Function(_$UnableToProcessDataImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = freezed,
    Object? stackTrace = freezed,
  }) {
    return _then(_$UnableToProcessDataImpl(
      freezed == error ? _value.error : error,
      freezed == stackTrace
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace?,
    ));
  }
}

/// @nodoc

class _$UnableToProcessDataImpl extends UnableToProcessData {
  const _$UnableToProcessDataImpl([this.error, this.stackTrace]) : super._();

  @override
  final Object? error;
  @override
  final StackTrace? stackTrace;

  @override
  String toString() {
    return 'HttpFailure.unableToProcessData(error: $error, stackTrace: $stackTrace)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnableToProcessDataImpl &&
            const DeepCollectionEquality().equals(other.error, error) &&
            (identical(other.stackTrace, stackTrace) ||
                other.stackTrace == stackTrace));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(error), stackTrace);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnableToProcessDataImplCopyWith<_$UnableToProcessDataImpl> get copyWith =>
      __$$UnableToProcessDataImplCopyWithImpl<_$UnableToProcessDataImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(DioException? error, StackTrace? stackTrace)
        connectionTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        sendTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        receiveTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        requestCancel,
    required TResult Function(SocketException? error, StackTrace? stackTrace)
        noInternetConnection,
    required TResult Function(Object? error, StackTrace? stackTrace)
        unableToProcessData,
    required TResult Function(Object? error, StackTrace? stackTrace)
        unexpectedError,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        informationalResponse,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        redirectionMessage,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        clientError,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        serverError,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        badCertificate,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        connectionError,
    required TResult Function(Object? error, StackTrace? stackTrace) unknown,
  }) {
    return unableToProcessData(error, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        connectionTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)? sendTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        receiveTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        requestCancel,
    TResult? Function(SocketException? error, StackTrace? stackTrace)?
        noInternetConnection,
    TResult? Function(Object? error, StackTrace? stackTrace)?
        unableToProcessData,
    TResult? Function(Object? error, StackTrace? stackTrace)? unexpectedError,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        informationalResponse,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        redirectionMessage,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        clientError,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        serverError,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        badCertificate,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        connectionError,
    TResult? Function(Object? error, StackTrace? stackTrace)? unknown,
  }) {
    return unableToProcessData?.call(error, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DioException? error, StackTrace? stackTrace)?
        connectionTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)? sendTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        receiveTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        requestCancel,
    TResult Function(SocketException? error, StackTrace? stackTrace)?
        noInternetConnection,
    TResult Function(Object? error, StackTrace? stackTrace)?
        unableToProcessData,
    TResult Function(Object? error, StackTrace? stackTrace)? unexpectedError,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        informationalResponse,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        redirectionMessage,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        clientError,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        serverError,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        badCertificate,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        connectionError,
    TResult Function(Object? error, StackTrace? stackTrace)? unknown,
    required TResult orElse(),
  }) {
    if (unableToProcessData != null) {
      return unableToProcessData(error, stackTrace);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConnectionTimeout value) connectionTimeout,
    required TResult Function(SendTimeout value) sendTimeout,
    required TResult Function(ReceiveTimeout value) receiveTimeout,
    required TResult Function(RequestCancelled value) requestCancel,
    required TResult Function(NoInternetConnection value) noInternetConnection,
    required TResult Function(UnableToProcessData value) unableToProcessData,
    required TResult Function(UnexpectedError value) unexpectedError,
    required TResult Function(InformationalResponse value)
        informationalResponse,
    required TResult Function(RedirectionMessage value) redirectionMessage,
    required TResult Function(ClientError value) clientError,
    required TResult Function(ServerError value) serverError,
    required TResult Function(BadCertificate value) badCertificate,
    required TResult Function(ConnectionError value) connectionError,
    required TResult Function(UnknownException value) unknown,
  }) {
    return unableToProcessData(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConnectionTimeout value)? connectionTimeout,
    TResult? Function(SendTimeout value)? sendTimeout,
    TResult? Function(ReceiveTimeout value)? receiveTimeout,
    TResult? Function(RequestCancelled value)? requestCancel,
    TResult? Function(NoInternetConnection value)? noInternetConnection,
    TResult? Function(UnableToProcessData value)? unableToProcessData,
    TResult? Function(UnexpectedError value)? unexpectedError,
    TResult? Function(InformationalResponse value)? informationalResponse,
    TResult? Function(RedirectionMessage value)? redirectionMessage,
    TResult? Function(ClientError value)? clientError,
    TResult? Function(ServerError value)? serverError,
    TResult? Function(BadCertificate value)? badCertificate,
    TResult? Function(ConnectionError value)? connectionError,
    TResult? Function(UnknownException value)? unknown,
  }) {
    return unableToProcessData?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConnectionTimeout value)? connectionTimeout,
    TResult Function(SendTimeout value)? sendTimeout,
    TResult Function(ReceiveTimeout value)? receiveTimeout,
    TResult Function(RequestCancelled value)? requestCancel,
    TResult Function(NoInternetConnection value)? noInternetConnection,
    TResult Function(UnableToProcessData value)? unableToProcessData,
    TResult Function(UnexpectedError value)? unexpectedError,
    TResult Function(InformationalResponse value)? informationalResponse,
    TResult Function(RedirectionMessage value)? redirectionMessage,
    TResult Function(ClientError value)? clientError,
    TResult Function(ServerError value)? serverError,
    TResult Function(BadCertificate value)? badCertificate,
    TResult Function(ConnectionError value)? connectionError,
    TResult Function(UnknownException value)? unknown,
    required TResult orElse(),
  }) {
    if (unableToProcessData != null) {
      return unableToProcessData(this);
    }
    return orElse();
  }
}

abstract class UnableToProcessData extends HttpFailure {
  const factory UnableToProcessData(
      [final Object? error,
      final StackTrace? stackTrace]) = _$UnableToProcessDataImpl;
  const UnableToProcessData._() : super._();

  @override
  Object? get error;
  @override
  StackTrace? get stackTrace;
  @override
  @JsonKey(ignore: true)
  _$$UnableToProcessDataImplCopyWith<_$UnableToProcessDataImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UnexpectedErrorImplCopyWith<$Res>
    implements $HttpFailureCopyWith<$Res> {
  factory _$$UnexpectedErrorImplCopyWith(_$UnexpectedErrorImpl value,
          $Res Function(_$UnexpectedErrorImpl) then) =
      __$$UnexpectedErrorImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Object? error, StackTrace? stackTrace});
}

/// @nodoc
class __$$UnexpectedErrorImplCopyWithImpl<$Res>
    extends _$HttpFailureCopyWithImpl<$Res, _$UnexpectedErrorImpl>
    implements _$$UnexpectedErrorImplCopyWith<$Res> {
  __$$UnexpectedErrorImplCopyWithImpl(
      _$UnexpectedErrorImpl _value, $Res Function(_$UnexpectedErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = freezed,
    Object? stackTrace = freezed,
  }) {
    return _then(_$UnexpectedErrorImpl(
      freezed == error ? _value.error : error,
      freezed == stackTrace
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace?,
    ));
  }
}

/// @nodoc

class _$UnexpectedErrorImpl extends UnexpectedError {
  const _$UnexpectedErrorImpl([this.error, this.stackTrace]) : super._();

  @override
  final Object? error;
  @override
  final StackTrace? stackTrace;

  @override
  String toString() {
    return 'HttpFailure.unexpectedError(error: $error, stackTrace: $stackTrace)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnexpectedErrorImpl &&
            const DeepCollectionEquality().equals(other.error, error) &&
            (identical(other.stackTrace, stackTrace) ||
                other.stackTrace == stackTrace));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(error), stackTrace);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnexpectedErrorImplCopyWith<_$UnexpectedErrorImpl> get copyWith =>
      __$$UnexpectedErrorImplCopyWithImpl<_$UnexpectedErrorImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(DioException? error, StackTrace? stackTrace)
        connectionTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        sendTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        receiveTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        requestCancel,
    required TResult Function(SocketException? error, StackTrace? stackTrace)
        noInternetConnection,
    required TResult Function(Object? error, StackTrace? stackTrace)
        unableToProcessData,
    required TResult Function(Object? error, StackTrace? stackTrace)
        unexpectedError,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        informationalResponse,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        redirectionMessage,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        clientError,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        serverError,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        badCertificate,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        connectionError,
    required TResult Function(Object? error, StackTrace? stackTrace) unknown,
  }) {
    return unexpectedError(error, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        connectionTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)? sendTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        receiveTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        requestCancel,
    TResult? Function(SocketException? error, StackTrace? stackTrace)?
        noInternetConnection,
    TResult? Function(Object? error, StackTrace? stackTrace)?
        unableToProcessData,
    TResult? Function(Object? error, StackTrace? stackTrace)? unexpectedError,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        informationalResponse,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        redirectionMessage,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        clientError,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        serverError,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        badCertificate,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        connectionError,
    TResult? Function(Object? error, StackTrace? stackTrace)? unknown,
  }) {
    return unexpectedError?.call(error, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DioException? error, StackTrace? stackTrace)?
        connectionTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)? sendTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        receiveTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        requestCancel,
    TResult Function(SocketException? error, StackTrace? stackTrace)?
        noInternetConnection,
    TResult Function(Object? error, StackTrace? stackTrace)?
        unableToProcessData,
    TResult Function(Object? error, StackTrace? stackTrace)? unexpectedError,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        informationalResponse,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        redirectionMessage,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        clientError,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        serverError,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        badCertificate,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        connectionError,
    TResult Function(Object? error, StackTrace? stackTrace)? unknown,
    required TResult orElse(),
  }) {
    if (unexpectedError != null) {
      return unexpectedError(error, stackTrace);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConnectionTimeout value) connectionTimeout,
    required TResult Function(SendTimeout value) sendTimeout,
    required TResult Function(ReceiveTimeout value) receiveTimeout,
    required TResult Function(RequestCancelled value) requestCancel,
    required TResult Function(NoInternetConnection value) noInternetConnection,
    required TResult Function(UnableToProcessData value) unableToProcessData,
    required TResult Function(UnexpectedError value) unexpectedError,
    required TResult Function(InformationalResponse value)
        informationalResponse,
    required TResult Function(RedirectionMessage value) redirectionMessage,
    required TResult Function(ClientError value) clientError,
    required TResult Function(ServerError value) serverError,
    required TResult Function(BadCertificate value) badCertificate,
    required TResult Function(ConnectionError value) connectionError,
    required TResult Function(UnknownException value) unknown,
  }) {
    return unexpectedError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConnectionTimeout value)? connectionTimeout,
    TResult? Function(SendTimeout value)? sendTimeout,
    TResult? Function(ReceiveTimeout value)? receiveTimeout,
    TResult? Function(RequestCancelled value)? requestCancel,
    TResult? Function(NoInternetConnection value)? noInternetConnection,
    TResult? Function(UnableToProcessData value)? unableToProcessData,
    TResult? Function(UnexpectedError value)? unexpectedError,
    TResult? Function(InformationalResponse value)? informationalResponse,
    TResult? Function(RedirectionMessage value)? redirectionMessage,
    TResult? Function(ClientError value)? clientError,
    TResult? Function(ServerError value)? serverError,
    TResult? Function(BadCertificate value)? badCertificate,
    TResult? Function(ConnectionError value)? connectionError,
    TResult? Function(UnknownException value)? unknown,
  }) {
    return unexpectedError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConnectionTimeout value)? connectionTimeout,
    TResult Function(SendTimeout value)? sendTimeout,
    TResult Function(ReceiveTimeout value)? receiveTimeout,
    TResult Function(RequestCancelled value)? requestCancel,
    TResult Function(NoInternetConnection value)? noInternetConnection,
    TResult Function(UnableToProcessData value)? unableToProcessData,
    TResult Function(UnexpectedError value)? unexpectedError,
    TResult Function(InformationalResponse value)? informationalResponse,
    TResult Function(RedirectionMessage value)? redirectionMessage,
    TResult Function(ClientError value)? clientError,
    TResult Function(ServerError value)? serverError,
    TResult Function(BadCertificate value)? badCertificate,
    TResult Function(ConnectionError value)? connectionError,
    TResult Function(UnknownException value)? unknown,
    required TResult orElse(),
  }) {
    if (unexpectedError != null) {
      return unexpectedError(this);
    }
    return orElse();
  }
}

abstract class UnexpectedError extends HttpFailure {
  const factory UnexpectedError(
      [final Object? error,
      final StackTrace? stackTrace]) = _$UnexpectedErrorImpl;
  const UnexpectedError._() : super._();

  @override
  Object? get error;
  @override
  StackTrace? get stackTrace;
  @override
  @JsonKey(ignore: true)
  _$$UnexpectedErrorImplCopyWith<_$UnexpectedErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InformationalResponseImplCopyWith<$Res>
    implements $HttpFailureCopyWith<$Res> {
  factory _$$InformationalResponseImplCopyWith(
          _$InformationalResponseImpl value,
          $Res Function(_$InformationalResponseImpl) then) =
      __$$InformationalResponseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({DioException? error, StackTrace? stackTrace, int? statusCode});
}

/// @nodoc
class __$$InformationalResponseImplCopyWithImpl<$Res>
    extends _$HttpFailureCopyWithImpl<$Res, _$InformationalResponseImpl>
    implements _$$InformationalResponseImplCopyWith<$Res> {
  __$$InformationalResponseImplCopyWithImpl(_$InformationalResponseImpl _value,
      $Res Function(_$InformationalResponseImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = freezed,
    Object? stackTrace = freezed,
    Object? statusCode = freezed,
  }) {
    return _then(_$InformationalResponseImpl(
      freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as DioException?,
      freezed == stackTrace
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace?,
      freezed == statusCode
          ? _value.statusCode
          : statusCode // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$InformationalResponseImpl extends InformationalResponse {
  const _$InformationalResponseImpl(
      [this.error, this.stackTrace, this.statusCode])
      : super._();

  @override
  final DioException? error;
  @override
  final StackTrace? stackTrace;
  @override
  final int? statusCode;

  @override
  String toString() {
    return 'HttpFailure.informationalResponse(error: $error, stackTrace: $stackTrace, statusCode: $statusCode)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InformationalResponseImpl &&
            (identical(other.error, error) || other.error == error) &&
            (identical(other.stackTrace, stackTrace) ||
                other.stackTrace == stackTrace) &&
            (identical(other.statusCode, statusCode) ||
                other.statusCode == statusCode));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error, stackTrace, statusCode);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InformationalResponseImplCopyWith<_$InformationalResponseImpl>
      get copyWith => __$$InformationalResponseImplCopyWithImpl<
          _$InformationalResponseImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(DioException? error, StackTrace? stackTrace)
        connectionTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        sendTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        receiveTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        requestCancel,
    required TResult Function(SocketException? error, StackTrace? stackTrace)
        noInternetConnection,
    required TResult Function(Object? error, StackTrace? stackTrace)
        unableToProcessData,
    required TResult Function(Object? error, StackTrace? stackTrace)
        unexpectedError,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        informationalResponse,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        redirectionMessage,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        clientError,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        serverError,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        badCertificate,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        connectionError,
    required TResult Function(Object? error, StackTrace? stackTrace) unknown,
  }) {
    return informationalResponse(error, stackTrace, statusCode);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        connectionTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)? sendTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        receiveTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        requestCancel,
    TResult? Function(SocketException? error, StackTrace? stackTrace)?
        noInternetConnection,
    TResult? Function(Object? error, StackTrace? stackTrace)?
        unableToProcessData,
    TResult? Function(Object? error, StackTrace? stackTrace)? unexpectedError,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        informationalResponse,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        redirectionMessage,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        clientError,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        serverError,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        badCertificate,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        connectionError,
    TResult? Function(Object? error, StackTrace? stackTrace)? unknown,
  }) {
    return informationalResponse?.call(error, stackTrace, statusCode);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DioException? error, StackTrace? stackTrace)?
        connectionTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)? sendTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        receiveTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        requestCancel,
    TResult Function(SocketException? error, StackTrace? stackTrace)?
        noInternetConnection,
    TResult Function(Object? error, StackTrace? stackTrace)?
        unableToProcessData,
    TResult Function(Object? error, StackTrace? stackTrace)? unexpectedError,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        informationalResponse,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        redirectionMessage,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        clientError,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        serverError,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        badCertificate,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        connectionError,
    TResult Function(Object? error, StackTrace? stackTrace)? unknown,
    required TResult orElse(),
  }) {
    if (informationalResponse != null) {
      return informationalResponse(error, stackTrace, statusCode);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConnectionTimeout value) connectionTimeout,
    required TResult Function(SendTimeout value) sendTimeout,
    required TResult Function(ReceiveTimeout value) receiveTimeout,
    required TResult Function(RequestCancelled value) requestCancel,
    required TResult Function(NoInternetConnection value) noInternetConnection,
    required TResult Function(UnableToProcessData value) unableToProcessData,
    required TResult Function(UnexpectedError value) unexpectedError,
    required TResult Function(InformationalResponse value)
        informationalResponse,
    required TResult Function(RedirectionMessage value) redirectionMessage,
    required TResult Function(ClientError value) clientError,
    required TResult Function(ServerError value) serverError,
    required TResult Function(BadCertificate value) badCertificate,
    required TResult Function(ConnectionError value) connectionError,
    required TResult Function(UnknownException value) unknown,
  }) {
    return informationalResponse(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConnectionTimeout value)? connectionTimeout,
    TResult? Function(SendTimeout value)? sendTimeout,
    TResult? Function(ReceiveTimeout value)? receiveTimeout,
    TResult? Function(RequestCancelled value)? requestCancel,
    TResult? Function(NoInternetConnection value)? noInternetConnection,
    TResult? Function(UnableToProcessData value)? unableToProcessData,
    TResult? Function(UnexpectedError value)? unexpectedError,
    TResult? Function(InformationalResponse value)? informationalResponse,
    TResult? Function(RedirectionMessage value)? redirectionMessage,
    TResult? Function(ClientError value)? clientError,
    TResult? Function(ServerError value)? serverError,
    TResult? Function(BadCertificate value)? badCertificate,
    TResult? Function(ConnectionError value)? connectionError,
    TResult? Function(UnknownException value)? unknown,
  }) {
    return informationalResponse?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConnectionTimeout value)? connectionTimeout,
    TResult Function(SendTimeout value)? sendTimeout,
    TResult Function(ReceiveTimeout value)? receiveTimeout,
    TResult Function(RequestCancelled value)? requestCancel,
    TResult Function(NoInternetConnection value)? noInternetConnection,
    TResult Function(UnableToProcessData value)? unableToProcessData,
    TResult Function(UnexpectedError value)? unexpectedError,
    TResult Function(InformationalResponse value)? informationalResponse,
    TResult Function(RedirectionMessage value)? redirectionMessage,
    TResult Function(ClientError value)? clientError,
    TResult Function(ServerError value)? serverError,
    TResult Function(BadCertificate value)? badCertificate,
    TResult Function(ConnectionError value)? connectionError,
    TResult Function(UnknownException value)? unknown,
    required TResult orElse(),
  }) {
    if (informationalResponse != null) {
      return informationalResponse(this);
    }
    return orElse();
  }
}

abstract class InformationalResponse extends HttpFailure {
  const factory InformationalResponse(
      [final DioException? error,
      final StackTrace? stackTrace,
      final int? statusCode]) = _$InformationalResponseImpl;
  const InformationalResponse._() : super._();

  @override
  DioException? get error;
  @override
  StackTrace? get stackTrace;
  int? get statusCode;
  @override
  @JsonKey(ignore: true)
  _$$InformationalResponseImplCopyWith<_$InformationalResponseImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$RedirectionMessageImplCopyWith<$Res>
    implements $HttpFailureCopyWith<$Res> {
  factory _$$RedirectionMessageImplCopyWith(_$RedirectionMessageImpl value,
          $Res Function(_$RedirectionMessageImpl) then) =
      __$$RedirectionMessageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({DioException? error, StackTrace? stackTrace, int? statusCode});
}

/// @nodoc
class __$$RedirectionMessageImplCopyWithImpl<$Res>
    extends _$HttpFailureCopyWithImpl<$Res, _$RedirectionMessageImpl>
    implements _$$RedirectionMessageImplCopyWith<$Res> {
  __$$RedirectionMessageImplCopyWithImpl(_$RedirectionMessageImpl _value,
      $Res Function(_$RedirectionMessageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = freezed,
    Object? stackTrace = freezed,
    Object? statusCode = freezed,
  }) {
    return _then(_$RedirectionMessageImpl(
      freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as DioException?,
      freezed == stackTrace
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace?,
      freezed == statusCode
          ? _value.statusCode
          : statusCode // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$RedirectionMessageImpl extends RedirectionMessage {
  const _$RedirectionMessageImpl([this.error, this.stackTrace, this.statusCode])
      : super._();

  @override
  final DioException? error;
  @override
  final StackTrace? stackTrace;
  @override
  final int? statusCode;

  @override
  String toString() {
    return 'HttpFailure.redirectionMessage(error: $error, stackTrace: $stackTrace, statusCode: $statusCode)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RedirectionMessageImpl &&
            (identical(other.error, error) || other.error == error) &&
            (identical(other.stackTrace, stackTrace) ||
                other.stackTrace == stackTrace) &&
            (identical(other.statusCode, statusCode) ||
                other.statusCode == statusCode));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error, stackTrace, statusCode);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RedirectionMessageImplCopyWith<_$RedirectionMessageImpl> get copyWith =>
      __$$RedirectionMessageImplCopyWithImpl<_$RedirectionMessageImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(DioException? error, StackTrace? stackTrace)
        connectionTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        sendTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        receiveTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        requestCancel,
    required TResult Function(SocketException? error, StackTrace? stackTrace)
        noInternetConnection,
    required TResult Function(Object? error, StackTrace? stackTrace)
        unableToProcessData,
    required TResult Function(Object? error, StackTrace? stackTrace)
        unexpectedError,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        informationalResponse,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        redirectionMessage,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        clientError,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        serverError,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        badCertificate,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        connectionError,
    required TResult Function(Object? error, StackTrace? stackTrace) unknown,
  }) {
    return redirectionMessage(error, stackTrace, statusCode);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        connectionTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)? sendTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        receiveTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        requestCancel,
    TResult? Function(SocketException? error, StackTrace? stackTrace)?
        noInternetConnection,
    TResult? Function(Object? error, StackTrace? stackTrace)?
        unableToProcessData,
    TResult? Function(Object? error, StackTrace? stackTrace)? unexpectedError,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        informationalResponse,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        redirectionMessage,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        clientError,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        serverError,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        badCertificate,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        connectionError,
    TResult? Function(Object? error, StackTrace? stackTrace)? unknown,
  }) {
    return redirectionMessage?.call(error, stackTrace, statusCode);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DioException? error, StackTrace? stackTrace)?
        connectionTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)? sendTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        receiveTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        requestCancel,
    TResult Function(SocketException? error, StackTrace? stackTrace)?
        noInternetConnection,
    TResult Function(Object? error, StackTrace? stackTrace)?
        unableToProcessData,
    TResult Function(Object? error, StackTrace? stackTrace)? unexpectedError,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        informationalResponse,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        redirectionMessage,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        clientError,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        serverError,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        badCertificate,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        connectionError,
    TResult Function(Object? error, StackTrace? stackTrace)? unknown,
    required TResult orElse(),
  }) {
    if (redirectionMessage != null) {
      return redirectionMessage(error, stackTrace, statusCode);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConnectionTimeout value) connectionTimeout,
    required TResult Function(SendTimeout value) sendTimeout,
    required TResult Function(ReceiveTimeout value) receiveTimeout,
    required TResult Function(RequestCancelled value) requestCancel,
    required TResult Function(NoInternetConnection value) noInternetConnection,
    required TResult Function(UnableToProcessData value) unableToProcessData,
    required TResult Function(UnexpectedError value) unexpectedError,
    required TResult Function(InformationalResponse value)
        informationalResponse,
    required TResult Function(RedirectionMessage value) redirectionMessage,
    required TResult Function(ClientError value) clientError,
    required TResult Function(ServerError value) serverError,
    required TResult Function(BadCertificate value) badCertificate,
    required TResult Function(ConnectionError value) connectionError,
    required TResult Function(UnknownException value) unknown,
  }) {
    return redirectionMessage(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConnectionTimeout value)? connectionTimeout,
    TResult? Function(SendTimeout value)? sendTimeout,
    TResult? Function(ReceiveTimeout value)? receiveTimeout,
    TResult? Function(RequestCancelled value)? requestCancel,
    TResult? Function(NoInternetConnection value)? noInternetConnection,
    TResult? Function(UnableToProcessData value)? unableToProcessData,
    TResult? Function(UnexpectedError value)? unexpectedError,
    TResult? Function(InformationalResponse value)? informationalResponse,
    TResult? Function(RedirectionMessage value)? redirectionMessage,
    TResult? Function(ClientError value)? clientError,
    TResult? Function(ServerError value)? serverError,
    TResult? Function(BadCertificate value)? badCertificate,
    TResult? Function(ConnectionError value)? connectionError,
    TResult? Function(UnknownException value)? unknown,
  }) {
    return redirectionMessage?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConnectionTimeout value)? connectionTimeout,
    TResult Function(SendTimeout value)? sendTimeout,
    TResult Function(ReceiveTimeout value)? receiveTimeout,
    TResult Function(RequestCancelled value)? requestCancel,
    TResult Function(NoInternetConnection value)? noInternetConnection,
    TResult Function(UnableToProcessData value)? unableToProcessData,
    TResult Function(UnexpectedError value)? unexpectedError,
    TResult Function(InformationalResponse value)? informationalResponse,
    TResult Function(RedirectionMessage value)? redirectionMessage,
    TResult Function(ClientError value)? clientError,
    TResult Function(ServerError value)? serverError,
    TResult Function(BadCertificate value)? badCertificate,
    TResult Function(ConnectionError value)? connectionError,
    TResult Function(UnknownException value)? unknown,
    required TResult orElse(),
  }) {
    if (redirectionMessage != null) {
      return redirectionMessage(this);
    }
    return orElse();
  }
}

abstract class RedirectionMessage extends HttpFailure {
  const factory RedirectionMessage(
      [final DioException? error,
      final StackTrace? stackTrace,
      final int? statusCode]) = _$RedirectionMessageImpl;
  const RedirectionMessage._() : super._();

  @override
  DioException? get error;
  @override
  StackTrace? get stackTrace;
  int? get statusCode;
  @override
  @JsonKey(ignore: true)
  _$$RedirectionMessageImplCopyWith<_$RedirectionMessageImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ClientErrorImplCopyWith<$Res>
    implements $HttpFailureCopyWith<$Res> {
  factory _$$ClientErrorImplCopyWith(
          _$ClientErrorImpl value, $Res Function(_$ClientErrorImpl) then) =
      __$$ClientErrorImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({DioException? error, StackTrace? stackTrace, int? statusCode});
}

/// @nodoc
class __$$ClientErrorImplCopyWithImpl<$Res>
    extends _$HttpFailureCopyWithImpl<$Res, _$ClientErrorImpl>
    implements _$$ClientErrorImplCopyWith<$Res> {
  __$$ClientErrorImplCopyWithImpl(
      _$ClientErrorImpl _value, $Res Function(_$ClientErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = freezed,
    Object? stackTrace = freezed,
    Object? statusCode = freezed,
  }) {
    return _then(_$ClientErrorImpl(
      freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as DioException?,
      freezed == stackTrace
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace?,
      freezed == statusCode
          ? _value.statusCode
          : statusCode // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$ClientErrorImpl extends ClientError {
  const _$ClientErrorImpl([this.error, this.stackTrace, this.statusCode])
      : super._();

  @override
  final DioException? error;
  @override
  final StackTrace? stackTrace;
  @override
  final int? statusCode;

  @override
  String toString() {
    return 'HttpFailure.clientError(error: $error, stackTrace: $stackTrace, statusCode: $statusCode)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ClientErrorImpl &&
            (identical(other.error, error) || other.error == error) &&
            (identical(other.stackTrace, stackTrace) ||
                other.stackTrace == stackTrace) &&
            (identical(other.statusCode, statusCode) ||
                other.statusCode == statusCode));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error, stackTrace, statusCode);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ClientErrorImplCopyWith<_$ClientErrorImpl> get copyWith =>
      __$$ClientErrorImplCopyWithImpl<_$ClientErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(DioException? error, StackTrace? stackTrace)
        connectionTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        sendTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        receiveTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        requestCancel,
    required TResult Function(SocketException? error, StackTrace? stackTrace)
        noInternetConnection,
    required TResult Function(Object? error, StackTrace? stackTrace)
        unableToProcessData,
    required TResult Function(Object? error, StackTrace? stackTrace)
        unexpectedError,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        informationalResponse,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        redirectionMessage,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        clientError,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        serverError,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        badCertificate,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        connectionError,
    required TResult Function(Object? error, StackTrace? stackTrace) unknown,
  }) {
    return clientError(error, stackTrace, statusCode);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        connectionTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)? sendTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        receiveTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        requestCancel,
    TResult? Function(SocketException? error, StackTrace? stackTrace)?
        noInternetConnection,
    TResult? Function(Object? error, StackTrace? stackTrace)?
        unableToProcessData,
    TResult? Function(Object? error, StackTrace? stackTrace)? unexpectedError,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        informationalResponse,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        redirectionMessage,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        clientError,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        serverError,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        badCertificate,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        connectionError,
    TResult? Function(Object? error, StackTrace? stackTrace)? unknown,
  }) {
    return clientError?.call(error, stackTrace, statusCode);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DioException? error, StackTrace? stackTrace)?
        connectionTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)? sendTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        receiveTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        requestCancel,
    TResult Function(SocketException? error, StackTrace? stackTrace)?
        noInternetConnection,
    TResult Function(Object? error, StackTrace? stackTrace)?
        unableToProcessData,
    TResult Function(Object? error, StackTrace? stackTrace)? unexpectedError,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        informationalResponse,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        redirectionMessage,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        clientError,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        serverError,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        badCertificate,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        connectionError,
    TResult Function(Object? error, StackTrace? stackTrace)? unknown,
    required TResult orElse(),
  }) {
    if (clientError != null) {
      return clientError(error, stackTrace, statusCode);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConnectionTimeout value) connectionTimeout,
    required TResult Function(SendTimeout value) sendTimeout,
    required TResult Function(ReceiveTimeout value) receiveTimeout,
    required TResult Function(RequestCancelled value) requestCancel,
    required TResult Function(NoInternetConnection value) noInternetConnection,
    required TResult Function(UnableToProcessData value) unableToProcessData,
    required TResult Function(UnexpectedError value) unexpectedError,
    required TResult Function(InformationalResponse value)
        informationalResponse,
    required TResult Function(RedirectionMessage value) redirectionMessage,
    required TResult Function(ClientError value) clientError,
    required TResult Function(ServerError value) serverError,
    required TResult Function(BadCertificate value) badCertificate,
    required TResult Function(ConnectionError value) connectionError,
    required TResult Function(UnknownException value) unknown,
  }) {
    return clientError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConnectionTimeout value)? connectionTimeout,
    TResult? Function(SendTimeout value)? sendTimeout,
    TResult? Function(ReceiveTimeout value)? receiveTimeout,
    TResult? Function(RequestCancelled value)? requestCancel,
    TResult? Function(NoInternetConnection value)? noInternetConnection,
    TResult? Function(UnableToProcessData value)? unableToProcessData,
    TResult? Function(UnexpectedError value)? unexpectedError,
    TResult? Function(InformationalResponse value)? informationalResponse,
    TResult? Function(RedirectionMessage value)? redirectionMessage,
    TResult? Function(ClientError value)? clientError,
    TResult? Function(ServerError value)? serverError,
    TResult? Function(BadCertificate value)? badCertificate,
    TResult? Function(ConnectionError value)? connectionError,
    TResult? Function(UnknownException value)? unknown,
  }) {
    return clientError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConnectionTimeout value)? connectionTimeout,
    TResult Function(SendTimeout value)? sendTimeout,
    TResult Function(ReceiveTimeout value)? receiveTimeout,
    TResult Function(RequestCancelled value)? requestCancel,
    TResult Function(NoInternetConnection value)? noInternetConnection,
    TResult Function(UnableToProcessData value)? unableToProcessData,
    TResult Function(UnexpectedError value)? unexpectedError,
    TResult Function(InformationalResponse value)? informationalResponse,
    TResult Function(RedirectionMessage value)? redirectionMessage,
    TResult Function(ClientError value)? clientError,
    TResult Function(ServerError value)? serverError,
    TResult Function(BadCertificate value)? badCertificate,
    TResult Function(ConnectionError value)? connectionError,
    TResult Function(UnknownException value)? unknown,
    required TResult orElse(),
  }) {
    if (clientError != null) {
      return clientError(this);
    }
    return orElse();
  }
}

abstract class ClientError extends HttpFailure {
  const factory ClientError(
      [final DioException? error,
      final StackTrace? stackTrace,
      final int? statusCode]) = _$ClientErrorImpl;
  const ClientError._() : super._();

  @override
  DioException? get error;
  @override
  StackTrace? get stackTrace;
  int? get statusCode;
  @override
  @JsonKey(ignore: true)
  _$$ClientErrorImplCopyWith<_$ClientErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ServerErrorImplCopyWith<$Res>
    implements $HttpFailureCopyWith<$Res> {
  factory _$$ServerErrorImplCopyWith(
          _$ServerErrorImpl value, $Res Function(_$ServerErrorImpl) then) =
      __$$ServerErrorImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({DioException? error, StackTrace? stackTrace, int? statusCode});
}

/// @nodoc
class __$$ServerErrorImplCopyWithImpl<$Res>
    extends _$HttpFailureCopyWithImpl<$Res, _$ServerErrorImpl>
    implements _$$ServerErrorImplCopyWith<$Res> {
  __$$ServerErrorImplCopyWithImpl(
      _$ServerErrorImpl _value, $Res Function(_$ServerErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = freezed,
    Object? stackTrace = freezed,
    Object? statusCode = freezed,
  }) {
    return _then(_$ServerErrorImpl(
      freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as DioException?,
      freezed == stackTrace
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace?,
      freezed == statusCode
          ? _value.statusCode
          : statusCode // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$ServerErrorImpl extends ServerError {
  const _$ServerErrorImpl([this.error, this.stackTrace, this.statusCode])
      : super._();

  @override
  final DioException? error;
  @override
  final StackTrace? stackTrace;
  @override
  final int? statusCode;

  @override
  String toString() {
    return 'HttpFailure.serverError(error: $error, stackTrace: $stackTrace, statusCode: $statusCode)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ServerErrorImpl &&
            (identical(other.error, error) || other.error == error) &&
            (identical(other.stackTrace, stackTrace) ||
                other.stackTrace == stackTrace) &&
            (identical(other.statusCode, statusCode) ||
                other.statusCode == statusCode));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error, stackTrace, statusCode);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ServerErrorImplCopyWith<_$ServerErrorImpl> get copyWith =>
      __$$ServerErrorImplCopyWithImpl<_$ServerErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(DioException? error, StackTrace? stackTrace)
        connectionTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        sendTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        receiveTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        requestCancel,
    required TResult Function(SocketException? error, StackTrace? stackTrace)
        noInternetConnection,
    required TResult Function(Object? error, StackTrace? stackTrace)
        unableToProcessData,
    required TResult Function(Object? error, StackTrace? stackTrace)
        unexpectedError,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        informationalResponse,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        redirectionMessage,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        clientError,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        serverError,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        badCertificate,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        connectionError,
    required TResult Function(Object? error, StackTrace? stackTrace) unknown,
  }) {
    return serverError(error, stackTrace, statusCode);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        connectionTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)? sendTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        receiveTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        requestCancel,
    TResult? Function(SocketException? error, StackTrace? stackTrace)?
        noInternetConnection,
    TResult? Function(Object? error, StackTrace? stackTrace)?
        unableToProcessData,
    TResult? Function(Object? error, StackTrace? stackTrace)? unexpectedError,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        informationalResponse,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        redirectionMessage,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        clientError,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        serverError,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        badCertificate,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        connectionError,
    TResult? Function(Object? error, StackTrace? stackTrace)? unknown,
  }) {
    return serverError?.call(error, stackTrace, statusCode);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DioException? error, StackTrace? stackTrace)?
        connectionTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)? sendTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        receiveTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        requestCancel,
    TResult Function(SocketException? error, StackTrace? stackTrace)?
        noInternetConnection,
    TResult Function(Object? error, StackTrace? stackTrace)?
        unableToProcessData,
    TResult Function(Object? error, StackTrace? stackTrace)? unexpectedError,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        informationalResponse,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        redirectionMessage,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        clientError,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        serverError,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        badCertificate,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        connectionError,
    TResult Function(Object? error, StackTrace? stackTrace)? unknown,
    required TResult orElse(),
  }) {
    if (serverError != null) {
      return serverError(error, stackTrace, statusCode);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConnectionTimeout value) connectionTimeout,
    required TResult Function(SendTimeout value) sendTimeout,
    required TResult Function(ReceiveTimeout value) receiveTimeout,
    required TResult Function(RequestCancelled value) requestCancel,
    required TResult Function(NoInternetConnection value) noInternetConnection,
    required TResult Function(UnableToProcessData value) unableToProcessData,
    required TResult Function(UnexpectedError value) unexpectedError,
    required TResult Function(InformationalResponse value)
        informationalResponse,
    required TResult Function(RedirectionMessage value) redirectionMessage,
    required TResult Function(ClientError value) clientError,
    required TResult Function(ServerError value) serverError,
    required TResult Function(BadCertificate value) badCertificate,
    required TResult Function(ConnectionError value) connectionError,
    required TResult Function(UnknownException value) unknown,
  }) {
    return serverError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConnectionTimeout value)? connectionTimeout,
    TResult? Function(SendTimeout value)? sendTimeout,
    TResult? Function(ReceiveTimeout value)? receiveTimeout,
    TResult? Function(RequestCancelled value)? requestCancel,
    TResult? Function(NoInternetConnection value)? noInternetConnection,
    TResult? Function(UnableToProcessData value)? unableToProcessData,
    TResult? Function(UnexpectedError value)? unexpectedError,
    TResult? Function(InformationalResponse value)? informationalResponse,
    TResult? Function(RedirectionMessage value)? redirectionMessage,
    TResult? Function(ClientError value)? clientError,
    TResult? Function(ServerError value)? serverError,
    TResult? Function(BadCertificate value)? badCertificate,
    TResult? Function(ConnectionError value)? connectionError,
    TResult? Function(UnknownException value)? unknown,
  }) {
    return serverError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConnectionTimeout value)? connectionTimeout,
    TResult Function(SendTimeout value)? sendTimeout,
    TResult Function(ReceiveTimeout value)? receiveTimeout,
    TResult Function(RequestCancelled value)? requestCancel,
    TResult Function(NoInternetConnection value)? noInternetConnection,
    TResult Function(UnableToProcessData value)? unableToProcessData,
    TResult Function(UnexpectedError value)? unexpectedError,
    TResult Function(InformationalResponse value)? informationalResponse,
    TResult Function(RedirectionMessage value)? redirectionMessage,
    TResult Function(ClientError value)? clientError,
    TResult Function(ServerError value)? serverError,
    TResult Function(BadCertificate value)? badCertificate,
    TResult Function(ConnectionError value)? connectionError,
    TResult Function(UnknownException value)? unknown,
    required TResult orElse(),
  }) {
    if (serverError != null) {
      return serverError(this);
    }
    return orElse();
  }
}

abstract class ServerError extends HttpFailure {
  const factory ServerError(
      [final DioException? error,
      final StackTrace? stackTrace,
      final int? statusCode]) = _$ServerErrorImpl;
  const ServerError._() : super._();

  @override
  DioException? get error;
  @override
  StackTrace? get stackTrace;
  int? get statusCode;
  @override
  @JsonKey(ignore: true)
  _$$ServerErrorImplCopyWith<_$ServerErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BadCertificateImplCopyWith<$Res>
    implements $HttpFailureCopyWith<$Res> {
  factory _$$BadCertificateImplCopyWith(_$BadCertificateImpl value,
          $Res Function(_$BadCertificateImpl) then) =
      __$$BadCertificateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({DioException? error, StackTrace? stackTrace});
}

/// @nodoc
class __$$BadCertificateImplCopyWithImpl<$Res>
    extends _$HttpFailureCopyWithImpl<$Res, _$BadCertificateImpl>
    implements _$$BadCertificateImplCopyWith<$Res> {
  __$$BadCertificateImplCopyWithImpl(
      _$BadCertificateImpl _value, $Res Function(_$BadCertificateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = freezed,
    Object? stackTrace = freezed,
  }) {
    return _then(_$BadCertificateImpl(
      freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as DioException?,
      freezed == stackTrace
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace?,
    ));
  }
}

/// @nodoc

class _$BadCertificateImpl extends BadCertificate {
  const _$BadCertificateImpl([this.error, this.stackTrace]) : super._();

  @override
  final DioException? error;
  @override
  final StackTrace? stackTrace;

  @override
  String toString() {
    return 'HttpFailure.badCertificate(error: $error, stackTrace: $stackTrace)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BadCertificateImpl &&
            (identical(other.error, error) || other.error == error) &&
            (identical(other.stackTrace, stackTrace) ||
                other.stackTrace == stackTrace));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error, stackTrace);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BadCertificateImplCopyWith<_$BadCertificateImpl> get copyWith =>
      __$$BadCertificateImplCopyWithImpl<_$BadCertificateImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(DioException? error, StackTrace? stackTrace)
        connectionTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        sendTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        receiveTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        requestCancel,
    required TResult Function(SocketException? error, StackTrace? stackTrace)
        noInternetConnection,
    required TResult Function(Object? error, StackTrace? stackTrace)
        unableToProcessData,
    required TResult Function(Object? error, StackTrace? stackTrace)
        unexpectedError,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        informationalResponse,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        redirectionMessage,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        clientError,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        serverError,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        badCertificate,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        connectionError,
    required TResult Function(Object? error, StackTrace? stackTrace) unknown,
  }) {
    return badCertificate(error, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        connectionTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)? sendTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        receiveTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        requestCancel,
    TResult? Function(SocketException? error, StackTrace? stackTrace)?
        noInternetConnection,
    TResult? Function(Object? error, StackTrace? stackTrace)?
        unableToProcessData,
    TResult? Function(Object? error, StackTrace? stackTrace)? unexpectedError,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        informationalResponse,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        redirectionMessage,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        clientError,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        serverError,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        badCertificate,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        connectionError,
    TResult? Function(Object? error, StackTrace? stackTrace)? unknown,
  }) {
    return badCertificate?.call(error, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DioException? error, StackTrace? stackTrace)?
        connectionTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)? sendTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        receiveTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        requestCancel,
    TResult Function(SocketException? error, StackTrace? stackTrace)?
        noInternetConnection,
    TResult Function(Object? error, StackTrace? stackTrace)?
        unableToProcessData,
    TResult Function(Object? error, StackTrace? stackTrace)? unexpectedError,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        informationalResponse,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        redirectionMessage,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        clientError,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        serverError,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        badCertificate,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        connectionError,
    TResult Function(Object? error, StackTrace? stackTrace)? unknown,
    required TResult orElse(),
  }) {
    if (badCertificate != null) {
      return badCertificate(error, stackTrace);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConnectionTimeout value) connectionTimeout,
    required TResult Function(SendTimeout value) sendTimeout,
    required TResult Function(ReceiveTimeout value) receiveTimeout,
    required TResult Function(RequestCancelled value) requestCancel,
    required TResult Function(NoInternetConnection value) noInternetConnection,
    required TResult Function(UnableToProcessData value) unableToProcessData,
    required TResult Function(UnexpectedError value) unexpectedError,
    required TResult Function(InformationalResponse value)
        informationalResponse,
    required TResult Function(RedirectionMessage value) redirectionMessage,
    required TResult Function(ClientError value) clientError,
    required TResult Function(ServerError value) serverError,
    required TResult Function(BadCertificate value) badCertificate,
    required TResult Function(ConnectionError value) connectionError,
    required TResult Function(UnknownException value) unknown,
  }) {
    return badCertificate(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConnectionTimeout value)? connectionTimeout,
    TResult? Function(SendTimeout value)? sendTimeout,
    TResult? Function(ReceiveTimeout value)? receiveTimeout,
    TResult? Function(RequestCancelled value)? requestCancel,
    TResult? Function(NoInternetConnection value)? noInternetConnection,
    TResult? Function(UnableToProcessData value)? unableToProcessData,
    TResult? Function(UnexpectedError value)? unexpectedError,
    TResult? Function(InformationalResponse value)? informationalResponse,
    TResult? Function(RedirectionMessage value)? redirectionMessage,
    TResult? Function(ClientError value)? clientError,
    TResult? Function(ServerError value)? serverError,
    TResult? Function(BadCertificate value)? badCertificate,
    TResult? Function(ConnectionError value)? connectionError,
    TResult? Function(UnknownException value)? unknown,
  }) {
    return badCertificate?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConnectionTimeout value)? connectionTimeout,
    TResult Function(SendTimeout value)? sendTimeout,
    TResult Function(ReceiveTimeout value)? receiveTimeout,
    TResult Function(RequestCancelled value)? requestCancel,
    TResult Function(NoInternetConnection value)? noInternetConnection,
    TResult Function(UnableToProcessData value)? unableToProcessData,
    TResult Function(UnexpectedError value)? unexpectedError,
    TResult Function(InformationalResponse value)? informationalResponse,
    TResult Function(RedirectionMessage value)? redirectionMessage,
    TResult Function(ClientError value)? clientError,
    TResult Function(ServerError value)? serverError,
    TResult Function(BadCertificate value)? badCertificate,
    TResult Function(ConnectionError value)? connectionError,
    TResult Function(UnknownException value)? unknown,
    required TResult orElse(),
  }) {
    if (badCertificate != null) {
      return badCertificate(this);
    }
    return orElse();
  }
}

abstract class BadCertificate extends HttpFailure {
  const factory BadCertificate(
      [final DioException? error,
      final StackTrace? stackTrace]) = _$BadCertificateImpl;
  const BadCertificate._() : super._();

  @override
  DioException? get error;
  @override
  StackTrace? get stackTrace;
  @override
  @JsonKey(ignore: true)
  _$$BadCertificateImplCopyWith<_$BadCertificateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ConnectionErrorImplCopyWith<$Res>
    implements $HttpFailureCopyWith<$Res> {
  factory _$$ConnectionErrorImplCopyWith(_$ConnectionErrorImpl value,
          $Res Function(_$ConnectionErrorImpl) then) =
      __$$ConnectionErrorImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({DioException? error, StackTrace? stackTrace});
}

/// @nodoc
class __$$ConnectionErrorImplCopyWithImpl<$Res>
    extends _$HttpFailureCopyWithImpl<$Res, _$ConnectionErrorImpl>
    implements _$$ConnectionErrorImplCopyWith<$Res> {
  __$$ConnectionErrorImplCopyWithImpl(
      _$ConnectionErrorImpl _value, $Res Function(_$ConnectionErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = freezed,
    Object? stackTrace = freezed,
  }) {
    return _then(_$ConnectionErrorImpl(
      freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as DioException?,
      freezed == stackTrace
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace?,
    ));
  }
}

/// @nodoc

class _$ConnectionErrorImpl extends ConnectionError {
  const _$ConnectionErrorImpl([this.error, this.stackTrace]) : super._();

  @override
  final DioException? error;
  @override
  final StackTrace? stackTrace;

  @override
  String toString() {
    return 'HttpFailure.connectionError(error: $error, stackTrace: $stackTrace)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConnectionErrorImpl &&
            (identical(other.error, error) || other.error == error) &&
            (identical(other.stackTrace, stackTrace) ||
                other.stackTrace == stackTrace));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error, stackTrace);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ConnectionErrorImplCopyWith<_$ConnectionErrorImpl> get copyWith =>
      __$$ConnectionErrorImplCopyWithImpl<_$ConnectionErrorImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(DioException? error, StackTrace? stackTrace)
        connectionTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        sendTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        receiveTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        requestCancel,
    required TResult Function(SocketException? error, StackTrace? stackTrace)
        noInternetConnection,
    required TResult Function(Object? error, StackTrace? stackTrace)
        unableToProcessData,
    required TResult Function(Object? error, StackTrace? stackTrace)
        unexpectedError,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        informationalResponse,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        redirectionMessage,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        clientError,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        serverError,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        badCertificate,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        connectionError,
    required TResult Function(Object? error, StackTrace? stackTrace) unknown,
  }) {
    return connectionError(error, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        connectionTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)? sendTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        receiveTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        requestCancel,
    TResult? Function(SocketException? error, StackTrace? stackTrace)?
        noInternetConnection,
    TResult? Function(Object? error, StackTrace? stackTrace)?
        unableToProcessData,
    TResult? Function(Object? error, StackTrace? stackTrace)? unexpectedError,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        informationalResponse,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        redirectionMessage,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        clientError,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        serverError,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        badCertificate,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        connectionError,
    TResult? Function(Object? error, StackTrace? stackTrace)? unknown,
  }) {
    return connectionError?.call(error, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DioException? error, StackTrace? stackTrace)?
        connectionTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)? sendTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        receiveTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        requestCancel,
    TResult Function(SocketException? error, StackTrace? stackTrace)?
        noInternetConnection,
    TResult Function(Object? error, StackTrace? stackTrace)?
        unableToProcessData,
    TResult Function(Object? error, StackTrace? stackTrace)? unexpectedError,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        informationalResponse,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        redirectionMessage,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        clientError,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        serverError,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        badCertificate,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        connectionError,
    TResult Function(Object? error, StackTrace? stackTrace)? unknown,
    required TResult orElse(),
  }) {
    if (connectionError != null) {
      return connectionError(error, stackTrace);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConnectionTimeout value) connectionTimeout,
    required TResult Function(SendTimeout value) sendTimeout,
    required TResult Function(ReceiveTimeout value) receiveTimeout,
    required TResult Function(RequestCancelled value) requestCancel,
    required TResult Function(NoInternetConnection value) noInternetConnection,
    required TResult Function(UnableToProcessData value) unableToProcessData,
    required TResult Function(UnexpectedError value) unexpectedError,
    required TResult Function(InformationalResponse value)
        informationalResponse,
    required TResult Function(RedirectionMessage value) redirectionMessage,
    required TResult Function(ClientError value) clientError,
    required TResult Function(ServerError value) serverError,
    required TResult Function(BadCertificate value) badCertificate,
    required TResult Function(ConnectionError value) connectionError,
    required TResult Function(UnknownException value) unknown,
  }) {
    return connectionError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConnectionTimeout value)? connectionTimeout,
    TResult? Function(SendTimeout value)? sendTimeout,
    TResult? Function(ReceiveTimeout value)? receiveTimeout,
    TResult? Function(RequestCancelled value)? requestCancel,
    TResult? Function(NoInternetConnection value)? noInternetConnection,
    TResult? Function(UnableToProcessData value)? unableToProcessData,
    TResult? Function(UnexpectedError value)? unexpectedError,
    TResult? Function(InformationalResponse value)? informationalResponse,
    TResult? Function(RedirectionMessage value)? redirectionMessage,
    TResult? Function(ClientError value)? clientError,
    TResult? Function(ServerError value)? serverError,
    TResult? Function(BadCertificate value)? badCertificate,
    TResult? Function(ConnectionError value)? connectionError,
    TResult? Function(UnknownException value)? unknown,
  }) {
    return connectionError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConnectionTimeout value)? connectionTimeout,
    TResult Function(SendTimeout value)? sendTimeout,
    TResult Function(ReceiveTimeout value)? receiveTimeout,
    TResult Function(RequestCancelled value)? requestCancel,
    TResult Function(NoInternetConnection value)? noInternetConnection,
    TResult Function(UnableToProcessData value)? unableToProcessData,
    TResult Function(UnexpectedError value)? unexpectedError,
    TResult Function(InformationalResponse value)? informationalResponse,
    TResult Function(RedirectionMessage value)? redirectionMessage,
    TResult Function(ClientError value)? clientError,
    TResult Function(ServerError value)? serverError,
    TResult Function(BadCertificate value)? badCertificate,
    TResult Function(ConnectionError value)? connectionError,
    TResult Function(UnknownException value)? unknown,
    required TResult orElse(),
  }) {
    if (connectionError != null) {
      return connectionError(this);
    }
    return orElse();
  }
}

abstract class ConnectionError extends HttpFailure {
  const factory ConnectionError(
      [final DioException? error,
      final StackTrace? stackTrace]) = _$ConnectionErrorImpl;
  const ConnectionError._() : super._();

  @override
  DioException? get error;
  @override
  StackTrace? get stackTrace;
  @override
  @JsonKey(ignore: true)
  _$$ConnectionErrorImplCopyWith<_$ConnectionErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UnknownExceptionImplCopyWith<$Res>
    implements $HttpFailureCopyWith<$Res> {
  factory _$$UnknownExceptionImplCopyWith(_$UnknownExceptionImpl value,
          $Res Function(_$UnknownExceptionImpl) then) =
      __$$UnknownExceptionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Object? error, StackTrace? stackTrace});
}

/// @nodoc
class __$$UnknownExceptionImplCopyWithImpl<$Res>
    extends _$HttpFailureCopyWithImpl<$Res, _$UnknownExceptionImpl>
    implements _$$UnknownExceptionImplCopyWith<$Res> {
  __$$UnknownExceptionImplCopyWithImpl(_$UnknownExceptionImpl _value,
      $Res Function(_$UnknownExceptionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = freezed,
    Object? stackTrace = freezed,
  }) {
    return _then(_$UnknownExceptionImpl(
      freezed == error ? _value.error : error,
      freezed == stackTrace
          ? _value.stackTrace
          : stackTrace // ignore: cast_nullable_to_non_nullable
              as StackTrace?,
    ));
  }
}

/// @nodoc

class _$UnknownExceptionImpl extends UnknownException {
  const _$UnknownExceptionImpl([this.error, this.stackTrace]) : super._();

  @override
  final Object? error;
  @override
  final StackTrace? stackTrace;

  @override
  String toString() {
    return 'HttpFailure.unknown(error: $error, stackTrace: $stackTrace)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnknownExceptionImpl &&
            const DeepCollectionEquality().equals(other.error, error) &&
            (identical(other.stackTrace, stackTrace) ||
                other.stackTrace == stackTrace));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(error), stackTrace);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnknownExceptionImplCopyWith<_$UnknownExceptionImpl> get copyWith =>
      __$$UnknownExceptionImplCopyWithImpl<_$UnknownExceptionImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(DioException? error, StackTrace? stackTrace)
        connectionTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        sendTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        receiveTimeout,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        requestCancel,
    required TResult Function(SocketException? error, StackTrace? stackTrace)
        noInternetConnection,
    required TResult Function(Object? error, StackTrace? stackTrace)
        unableToProcessData,
    required TResult Function(Object? error, StackTrace? stackTrace)
        unexpectedError,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        informationalResponse,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        redirectionMessage,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        clientError,
    required TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)
        serverError,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        badCertificate,
    required TResult Function(DioException? error, StackTrace? stackTrace)
        connectionError,
    required TResult Function(Object? error, StackTrace? stackTrace) unknown,
  }) {
    return unknown(error, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        connectionTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)? sendTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        receiveTimeout,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        requestCancel,
    TResult? Function(SocketException? error, StackTrace? stackTrace)?
        noInternetConnection,
    TResult? Function(Object? error, StackTrace? stackTrace)?
        unableToProcessData,
    TResult? Function(Object? error, StackTrace? stackTrace)? unexpectedError,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        informationalResponse,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        redirectionMessage,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        clientError,
    TResult? Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        serverError,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        badCertificate,
    TResult? Function(DioException? error, StackTrace? stackTrace)?
        connectionError,
    TResult? Function(Object? error, StackTrace? stackTrace)? unknown,
  }) {
    return unknown?.call(error, stackTrace);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(DioException? error, StackTrace? stackTrace)?
        connectionTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)? sendTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        receiveTimeout,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        requestCancel,
    TResult Function(SocketException? error, StackTrace? stackTrace)?
        noInternetConnection,
    TResult Function(Object? error, StackTrace? stackTrace)?
        unableToProcessData,
    TResult Function(Object? error, StackTrace? stackTrace)? unexpectedError,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        informationalResponse,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        redirectionMessage,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        clientError,
    TResult Function(
            DioException? error, StackTrace? stackTrace, int? statusCode)?
        serverError,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        badCertificate,
    TResult Function(DioException? error, StackTrace? stackTrace)?
        connectionError,
    TResult Function(Object? error, StackTrace? stackTrace)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(error, stackTrace);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConnectionTimeout value) connectionTimeout,
    required TResult Function(SendTimeout value) sendTimeout,
    required TResult Function(ReceiveTimeout value) receiveTimeout,
    required TResult Function(RequestCancelled value) requestCancel,
    required TResult Function(NoInternetConnection value) noInternetConnection,
    required TResult Function(UnableToProcessData value) unableToProcessData,
    required TResult Function(UnexpectedError value) unexpectedError,
    required TResult Function(InformationalResponse value)
        informationalResponse,
    required TResult Function(RedirectionMessage value) redirectionMessage,
    required TResult Function(ClientError value) clientError,
    required TResult Function(ServerError value) serverError,
    required TResult Function(BadCertificate value) badCertificate,
    required TResult Function(ConnectionError value) connectionError,
    required TResult Function(UnknownException value) unknown,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConnectionTimeout value)? connectionTimeout,
    TResult? Function(SendTimeout value)? sendTimeout,
    TResult? Function(ReceiveTimeout value)? receiveTimeout,
    TResult? Function(RequestCancelled value)? requestCancel,
    TResult? Function(NoInternetConnection value)? noInternetConnection,
    TResult? Function(UnableToProcessData value)? unableToProcessData,
    TResult? Function(UnexpectedError value)? unexpectedError,
    TResult? Function(InformationalResponse value)? informationalResponse,
    TResult? Function(RedirectionMessage value)? redirectionMessage,
    TResult? Function(ClientError value)? clientError,
    TResult? Function(ServerError value)? serverError,
    TResult? Function(BadCertificate value)? badCertificate,
    TResult? Function(ConnectionError value)? connectionError,
    TResult? Function(UnknownException value)? unknown,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConnectionTimeout value)? connectionTimeout,
    TResult Function(SendTimeout value)? sendTimeout,
    TResult Function(ReceiveTimeout value)? receiveTimeout,
    TResult Function(RequestCancelled value)? requestCancel,
    TResult Function(NoInternetConnection value)? noInternetConnection,
    TResult Function(UnableToProcessData value)? unableToProcessData,
    TResult Function(UnexpectedError value)? unexpectedError,
    TResult Function(InformationalResponse value)? informationalResponse,
    TResult Function(RedirectionMessage value)? redirectionMessage,
    TResult Function(ClientError value)? clientError,
    TResult Function(ServerError value)? serverError,
    TResult Function(BadCertificate value)? badCertificate,
    TResult Function(ConnectionError value)? connectionError,
    TResult Function(UnknownException value)? unknown,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class UnknownException extends HttpFailure {
  const factory UnknownException(
      [final Object? error,
      final StackTrace? stackTrace]) = _$UnknownExceptionImpl;
  const UnknownException._() : super._();

  @override
  Object? get error;
  @override
  StackTrace? get stackTrace;
  @override
  @JsonKey(ignore: true)
  _$$UnknownExceptionImplCopyWith<_$UnknownExceptionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
